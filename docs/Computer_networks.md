# 计算机网络八股

## 应用层
### TCP 的长连接和短连接
- 连接的建立：客户端向服务端发送连接请求，服务端收到请求，建立连接。客户端向服务端发送消息，服务端回应，完成一次读写。

- **短连接：** 完成读写后，客户端或服务端一方发起 close 操作，或由服务端主动关闭 TCP 请求。这样其他的 HTTP 请求，需要重新建立新的连接，且多个请求不能由一个连接共用。

- **长连接：** 完成读写后，服务端暂时不关闭连接，而是持续接收其他的请求。
	- 问题：连接长时间不关闭，客户端会占用服务端过多的资源，影响其他客户端的请求。
    - 解决方法：Keepalive (保活机制)。当客户端在一段时间（如 2h）内不活跃，服务器会尝试发送报文。如果没有收到回应，则每隔一段时间持续发送，直到达到阈值（保活次数）后，断开连接。过程在内核完成。

发送探测报文时客户端的状态：
1. 客户端正常，但未回应，达到保活次数，断开连接
2. 客户端正常，但因网络原因没有收到报文
3. 客户端崩溃，未响应报文
4. 客户端崩溃后重启，服务端收到报文，主动断开连接

### HTTP 的迭代历史
HTTP 1.0: 短连接，开销大
HTTP 1.1: 
- 缓存处理：引入 Entity tag 等缓存策略和缓存头
- 长连接：keep-alive, 请求流水线
- 带宽优化：请求头加入 range 头域，允许之请求资源的某个部分，便于优化带宽和网络连接
- Host 头
- 会产生队头阻塞问题
HTTP 2.0: 二进制帧、多路复用、头部压缩。提升并发性能
HTTP 3.0: 基于 QUIC (UDP)、0-RTT

HTTP 的 Keep-Alive: 即 HTTP 长连接，而非保活


## 传输层
### TCP 核心机制
**TCP 的基本特点：**
- 面向连接：一对一连接，一个主机不能向多个主机发送消息
- 可靠的：不论网络链路发生何种变化，报文一定能到达接收端
- 基于字节流：
	- 可以传输**无边界**（不限大小）的消息
    - 保证消息的**有序性**：前一个消息没收到时，不会将后面的字节交给应用层处理。会丢弃重复的报文。

#### 【重要】TCP 三次握手
开始建立连接，服务器主动监听特定端口，进入 LISTEN 状态
1. 第一次握手 (客户端 -> 服务器)
    - 客户端发送报文给服务器，请求建立连接，报文包括
	    - SYN = 1: 请求建立连接
        - 序列号 seq = x: 随机生成一个初始序列号
        - ACK = 0: 第一次握手待服务器确认
    - 客户端进入 SYN_SENT 状态，等待服务器确认
2. 第二次握手 (服务器 -> 客户端)
    - 服务器收到，同意建立连接，发送响应报文
	    - SYN = 1: 同意建立连接
        - ACK = 1: 确认客户端的 SYN
        - 序列号 seq = y: 发送服务器随机生成的初始序列号
        - 确认号 ack = x + 1: 期待收到客户端的第 x+1 个字节数据
    - 服务器进入 SYN_RECEIVED 状态，确认客户端请求
3. 第三次握手 (客户端 -> 服务器)
    - 客户端收到服务器的 STN+ACK 报文后，发送回应报文：
	    - ACK = 1: 确认服务器的SYN
        - seq = x + 1
        - ack = y + 1: 期待收到服务器的第 y+1 字节数据
    - 客户端进入 ESTABLISHED 状态
    - 服务器收到 ACK 报文后，也进入 ESTABLISHED 状态
    - 这次报文可以携带数据发送到服务器

#### 为什么是三次握手，不是两次、四次？
- 避免历史连接（最关键）
	- 历史连接：网络拥堵时，客户端会连续发送多个 SYN 请求建立连接，而旧的 SYN 报文会比新的 SYN 报文更早被服务器接收，产生历史连接。
    - 拒绝历史连接：通过 seq 和 ack 让客户端判断是否为历史报文。如，同时接收到 seq = 90 和 seq = 100 两个报文时，第二次握手中服务器 ack = 91, 这样第三次握手中客户端发现是历史报文，则会发送 RST 报文让服务器中止本次连接，直到下一次连接请求报文 (seq = 100)。
- 同步双方序列号
- 避免资源浪费

### 【重要】TCP 四次挥手
初始状态：客户端和服务器均为 ESTABLISHED 状态
假设由客户端主动申请关闭，发送 FIN 报文。

1. 第一次挥手 (客户端 -> 服务器)
    - 客户端主动发出关闭报文 FIN = 1
	    - FIN = 1: 请求关闭连接
        - 序列号 seq = u: u 等于已传送数据的最后一个字节序号 + 1
    - 客户端进入 **FIN_WAIT_1** 状态

2. 第二次挥手 (服务器 w-> 客户端)
	- 服务器收到 FIN 报文后，立即发送 ACK 确认报文
	    - ACK = 1: 确认收到客户端的关闭请求报文
        - ack = u+1: 确认客户端的 FIN
        - seq = v: 发送服务器当前的序列号 v
    - 服务器进入 **CLOSE_WAIT** 状态
    - 客户端收到 ACK 后进入 **FIN_WAIT_2** 状态

此时进入**“半关闭状态”**。
- 客户端->服务器方向关闭，客户端无法发送数据
- 服务器->客户端方向仍开发，服务器可以继续发送数据
接下来由服务器发送 FIN 报文，申请结束数据发送。

3. 第三次挥手 (**服务器 -> 客户端**)
    - 服务器完成数据发送后，发送 FIN 报文
	    - FIN = 1
        - ACK = 1
        - seq = w: 服务器随机生成或仍等于 v
        - ack = u+1: 确认最初客户端的 FIN
    - 服务器进入 **LAST_ACK** 状态

4. 第四次挥手 (客户端 -> 服务器)
    - 客户端收到服务器的 FIN 后，发送最后的 ACK 报文
	    - ACK = 1
        - ack = w+1: 确认服务器的 FIN
        - seq = u+1
    - 客户端进入 **TIME_WAIT** 状态，等待 2MSL (最长报文段寿命的两倍) 后进入 **CLOSED** 状态
    - 服务器收到 ACK 后立即进入 **CLOSED** 状态

### TCP 与 UDP 的区别
- 连接：
	- TCP：面向连接的，先建立连接再传输数据
    - UDP: 无连接
- 可靠性：
	- TCP: 传输的数据无差错、不丢失、不重复、按序到达
    - UDP: 不保证可靠性
- 服务对象：
	- TCP: 点对点服务
    - UDP: 不限，可多对多
- 传输方式：
	- TCP: 面向字节流，保证顺序和可靠
    - UDP：面向报文，不存在这类问题
- 拥塞和流量控制
	- TCP: 使用滑动窗口（流量控制）和慢启动（拥塞控制）
    - UDP：无
- 首部开销：
	- TCP: 20-60 字节
    - UDP: 固定 8 字节
- 传输效率
	- TCP: 较低
    - UDP: 较高


## I/O 多路复用机制
**概念：** 支持单个进程/线程可以同时监听多个文件描述符 (如 socket) 的就绪状态。让程序可以在多个 IO 通道上等待，当其中一个通道准备好执行 IO 操作时，程序就会得到通知。

不同的线程监听策略：
- BIO (Blocking IO): 一个线程监控一个连接，10 万个连接就需要 10 万个线程。会导致严重的 **上下文切换**爆炸，CPU大多数时间都在切换线程，难以处理任务。
- NIO (Non-blocking IO): 线程不阻塞，但需要轮询 (polling)
- IO 多路复用 (Multiplexing): 一个线程监控 10 万个连接，有数据传输过来时，得到提醒，立即处理。

## 【重要】 Select vs Poll vs Epoll
- Select / Poll (老旧， O(N)):
	- 原理：需要把所有连接的文件描述符 (FD) 从用户态拷贝到内核态。内核需要全部遍历一遍，找出有数据的 FD
    - 瓶颈：连接数越多则越慢（线性下降）。
    - Select 有 1024 个连接的硬限制，Poll 没有限制。但效率没有变化。
    
- Epoll (现代， O(1)):
	- 原理：
        1. 基于**红黑树 (RB-Tree)** 的实现：内核中维护一个红黑树，**保存所有待监控的连接**。增删改查只需要 O(logN), 且不需要每次把 FD 从用户态和内核态之间拷贝。
        2. **就绪链表 (Ready List):** 双向链表，连接有数据时（就绪状态），将 FD 存入链表。如果就绪链表非空，直接从中取出 FD 进行处理。
        3. **回调机制 (Call-back):** 内核会为每个 FD 设置回调。事件发生时，将 FD 存入就绪链表。
        4. **等待队列：** 当 epoll_wait 的进程阻塞时，加入等待队列，等待进程被唤醒时执行。
    
    - 三大核心机制：
        1. **epoll_create**
            - 在内核分配资源，创建内核数据结构，返回一个 FD 指向 epoll 实例
            - 数据结构包括：红黑树、就绪链表、等待队列
        2. **epoll_ctl**
            - 支持 ADD (增加 FD)、MOD (修改 FD)、DEL (删除 FD) 操作
            - 内核处理流程：查找红黑树 -> 执行操作 -> 设置回调
        3. **epoll_wait**
            - 检查就绪链表：链表非空，就取出事件返回
            - 进程等待：如果链表为空，就将当前进程加入等待队列，并调度其他进程执行。进程被唤醒时，将其从队列中移除。
            - 回调机制：FD 事件发生 -> 启动回调 -> 加入就绪链表 -> 唤醒进程，并从等待队列移除


## 水平触发 (LT) 和 边缘触发 (ET)
- 水平触发：默认触发模式。只要缓存区中还有数据，内核就会一直提醒
	- 优点：编程简单、不易丢失数据
    - 缺点：频繁通知、系统调用开销大
    
- 边缘触发：高性能触发模式。数据从无到有（或从少变多）的一瞬间，内核只提醒一次
	- 要求：必须一次性把数据读完，否则其他的数据保留在缓存区、不再提醒。
