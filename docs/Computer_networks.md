# 计算机网络八股

## 应用层
### TCP 的长连接和短连接
- 连接的建立：客户端向服务端发送连接请求，服务端收到请求，建立连接。客户端向服务端发送消息，服务端回应，完成一次读写。

- **短连接：** 完成读写后，客户端或服务端一方发起 close 操作，或由服务端主动关闭 TCP 请求。这样其他的 HTTP 请求，需要重新建立新的连接，且多个请求不能由一个连接共用。

- **长连接：** 完成读写后，服务端暂时不关闭连接，而是持续接收其他的请求。
	- 问题：连接长时间不关闭，客户端会占用服务端过多的资源，影响其他客户端的请求。
    - 解决方法：Keepalive (保活机制)。当客户端在一段时间（如 2h）内不活跃，服务器会尝试发送报文。如果没有收到回应，则每隔一段时间持续发送，直到达到阈值（保活次数）后，断开连接。过程在内核完成。

发送探测报文时客户端的状态：
1. 客户端正常，但未回应，达到保活次数，断开连接
2. 客户端正常，但因网络原因没有收到报文
3. 客户端崩溃，未响应报文
4. 客户端崩溃后重启，服务端收到报文，主动断开连接

### HTTP 的迭代历史
HTTP 1.0: 短连接，开销大
HTTP 1.1: 
- 缓存处理：引入 Entity tag 等缓存策略和缓存头
- 长连接：keep-alive, 请求流水线
- 带宽优化：请求头加入 range 头域，允许之请求资源的某个部分，便于优化带宽和网络连接
- Host 头
- 会产生队头阻塞问题
HTTP 2.0: 二进制帧、多路复用、头部压缩。提升并发性能
HTTP 3.0: 基于 QUIC (UDP)、0-RTT

HTTP 的 Keep-Alive: 即 HTTP 长连接，而非保活


## 传输层
### TCP 核心机制
**TCP 的基本特点：**
- 面向连接：一对一连接，一个主机不能向多个主机发送消息
- 可靠的：不论网络链路发生何种变化，报文一定能到达接收端
- 基于字节流：
	- 可以传输**无边界**（不限大小）的消息
    - 保证消息的**有序性**：前一个消息没收到时，不会将后面的字节交给应用层处理。会丢弃重复的报文。

#### 【重要】TCP 三次握手
开始建立连接，服务器主动监听特定端口，进入 LISTEN 状态
1. 第一次握手 (客户端 -> 服务器)
    - 客户端发送报文给服务器，请求建立连接，报文包括
	    - SYN = 1: 请求建立连接
        - 序列号 seq = x: 随机生成一个初始序列号
        - ACK = 0: 第一次握手待服务器确认
    - 客户端进入 SYN_SENT 状态，等待服务器确认
2. 第二次握手 (服务器 -> 客户端)
    - 服务器收到，同意建立连接，发送响应报文
	    - SYN = 1: 同意建立连接
        - ACK = 1: 确认客户端的 SYN
        - 序列号 seq = y: 发送服务器随机生成的初始序列号
        - 确认号 ack = x + 1: 期待收到客户端的第 x+1 个字节数据
    - 服务器进入 SYN_RECEIVED 状态，确认客户端请求
3. 第三次握手 (客户端 -> 服务器)
    - 客户端收到服务器的 STN+ACK 报文后，发送回应报文：
	    - ACK = 1: 确认服务器的SYN
        - seq = x + 1
        - ack = y + 1: 期待收到服务器的第 y+1 字节数据
    - 客户端进入 ESTABLISHED 状态
    - 服务器收到 ACK 报文后，也进入 ESTABLISHED 状态
    - 这次报文可以携带数据发送到服务器

#### 为什么是三次握手，不是两次、四次？
- 避免历史连接（最关键）
	- 历史连接：网络拥堵时，客户端会连续发送多个 SYN 请求建立连接，而旧的 SYN 报文会比新的 SYN 报文更早被服务器接收，产生历史连接。
    - 拒绝历史连接：通过 seq 和 ack 让客户端判断是否为历史报文。如，同时接收到 seq = 90 和 seq = 100 两个报文时，第二次握手中服务器 ack = 91, 这样第三次握手中客户端发现是历史报文，则会发送 RST 报文让服务器中止本次连接，直到下一次连接请求报文 (seq = 100)。
- 同步双方序列号
- 避免资源浪费

### 【重要】TCP 四次挥手
初始状态：客户端和服务器均为 ESTABLISHED 状态
假设由客户端主动申请关闭，发送 FIN 报文。

1. 第一次挥手 (客户端 -> 服务器)
    - 客户端主动发出关闭报文 FIN = 1
	    - FIN = 1: 请求关闭连接
        - 序列号 seq = u: u 等于已传送数据的最后一个字节序号 + 1
    - 客户端进入 **FIN_WAIT_1** 状态

2. 第二次挥手 (服务器 w-> 客户端)
	- 服务器收到 FIN 报文后，立即发送 ACK 确认报文
	    - ACK = 1: 确认收到客户端的关闭请求报文
        - ack = u+1: 确认客户端的 FIN
        - seq = v: 发送服务器当前的序列号 v
    - 服务器进入 **CLOSE_WAIT** 状态
    - 客户端收到 ACK 后进入 **FIN_WAIT_2** 状态

此时进入**“半关闭状态”**。
- 客户端->服务器方向关闭，客户端无法发送数据
- 服务器->客户端方向仍开发，服务器可以继续发送数据
接下来由服务器发送 FIN 报文，申请结束数据发送。

3. 第三次挥手 (**服务器 -> 客户端**)
    - 服务器完成数据发送后，发送 FIN 报文
	    - FIN = 1
        - ACK = 1
        - seq = w: 服务器随机生成或仍等于 v
        - ack = u+1: 确认最初客户端的 FIN
    - 服务器进入 **LAST_ACK** 状态

4. 第四次挥手 (客户端 -> 服务器)
    - 客户端收到服务器的 FIN 后，发送最后的 ACK 报文
	    - ACK = 1
        - ack = w+1: 确认服务器的 FIN
        - seq = u+1
    - 客户端进入 **TIME_WAIT** 状态，等待 2MSL (最长报文段寿命的两倍) 后进入 **CLOSED** 状态
    - 服务器收到 ACK 后立即进入 **CLOSED** 状态

### TCP 与 UDP 的区别
- 连接：
	- TCP：面向连接的，先建立连接再传输数据
    - UDP: 无连接
- 可靠性：
	- TCP: 传输的数据无差错、不丢失、不重复、按序到达
    - UDP: 不保证可靠性
- 服务对象：
	- TCP: 点对点服务
    - UDP: 不限，可多对多
- 传输方式：
	- TCP: 面向字节流，保证顺序和可靠
    - UDP：面向报文，不存在这类问题
- 拥塞和流量控制
	- TCP: 使用滑动窗口（流量控制）和慢启动（拥塞控制）
    - UDP：无
- 首部开销：
	- TCP: 20-60 字节
    - UDP: 固定 8 字节
- 传输效率
	- TCP: 较低
    - UDP: 较高


## I/O 多路复用机制 与 select/poll/epoll
**概念：** 支持单个进程/线程可以同时监听多个文件描述符 (如 socket) 的就绪状态。让程序可以在多个 IO 通道上等待，当其中一个通道准备好执行 IO 操作时，程序就会得到通知。
