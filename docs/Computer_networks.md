# 计算机网络八股

## 应用层
### TCP 的长连接和短连接
- 连接的建立：客户端向服务端发送连接请求，服务端收到请求，建立连接。客户端向服务端发送消息，服务端回应，完成一次读写。

- **短连接：** 完成读写后，客户端或服务端一方发起 close 操作，或由服务端主动关闭 TCP 请求。这样其他的 HTTP 请求，需要重新建立新的连接，且多个请求不能由一个连接共用。

- **长连接：** 完成读写后，服务端暂时不关闭连接，而是持续接收其他的请求。
	- 问题：连接长时间不关闭，客户端会占用服务端过多的资源，影响其他客户端的请求。
    - 解决方法：Keepalive (保活机制)。当客户端在一段时间（如 2h）内不活跃，服务器会尝试发送报文。如果没有收到回应，则每隔一段时间持续发送，直到达到阈值（保活次数）后，断开连接。过程在内核完成。

发送探测报文时客户端的状态：
1. 客户端正常，但未回应，达到保活次数，断开连接
2. 客户端正常，但因网络原因没有收到报文
3. 客户端崩溃，未响应报文
4. 客户端崩溃后重启，服务端收到报文，主动断开连接

### HTTP 的迭代历史
HTTP 1.0: 短连接，开销大
HTTP 1.1: 
- 缓存处理：引入 Entity tag 等缓存策略和缓存头
- 长连接：keep-alive, 请求流水线
- 带宽优化：请求头加入 range 头域，允许之请求资源的某个部分，便于优化带宽和网络连接
- Host 头
- 会产生队头阻塞问题
HTTP 2.0: 二进制帧、多路复用、头部压缩。提升并发性能
HTTP 3.0: 基于 QUIC (UDP)、0-RTT

HTTP 的 Keep-Alive: 即 HTTP 长连接，而非保活


## 传输层
### TCP 核心机制
**TCP 的基本特点：**
- 面向连接：一对一连接，一个主机不能向多个主机发送消息
- 可靠的：不论网络链路发生何种变化，报文一定能到达接收端
- 基于字节流：
	- 可以传输**无边界**（不限大小）的消息
    - 保证消息的**有序性**：前一个消息没收到时，不会将后面的字节交给应用层处理。会丢弃重复的报文。

#### 【重要】TCP 三次握手
开始建立连接，服务器主动监听特定端口，进入 LISTEN 状态
1. 第一次握手 (客户端 -> 服务器)
    - 客户端发送报文给服务器，请求建立连接，报文包括
	    - SYN = 1: 请求建立连接
        - 序列号 seq = x: 随机生成一个初始序列号
        - ACK = 0: 第一次握手待服务器确认
    - 客户端进入 SYN_SENT 状态，等待服务器确认
2. 第二次握手 (服务器 -> 客户端)
    - 服务器收到，同意建立连接，发送响应报文
	    - SYN = 1: 同意建立连接
        - ACK = 1: 确认客户端的 SYN
        - 序列号 seq = y: 发送服务器随机生成的初始序列号
        - 确认号 ack = x + 1: 期待收到客户端的第 x+1 个字节数据
    - 服务器进入 SYN_RECEIVED 状态，确认客户端请求
3. 第三次握手 (客户端 -> 服务器)
    - 客户端收到服务器的 STN+ACK 报文后，发送回应报文：
	    - ACK = 1: 确认服务器的SYN
        - seq = x + 1
        - ack = y + 1: 期待收到服务器的第 y+1 字节数据
    - 客户端进入 ESTABLISHED 状态
    - 服务器收到 ACK 报文后，也进入 ESTABLISHED 状态
    - 这次报文可以携带数据发送到服务器

#### 为什么是三次握手，不是两次、四次？
- 避免历史连接（最关键）
	- 历史连接：网络拥堵时，客户端会连续发送多个 SYN 请求建立连接，而旧的 SYN 报文会比新的 SYN 报文更早被服务器接收，产生历史连接。
    - 拒绝历史连接：通过 seq 和 ack 让客户端判断是否为历史报文。如，同时接收到 seq = 90 和 seq = 100 两个报文时，第二次握手中服务器 ack = 91, 这样第三次握手中客户端发现是历史报文，则会发送 RST 报文让服务器中止本次连接，直到下一次连接请求报文 (seq = 100)。
- 同步双方序列号
- 避免资源浪费

### 【重要】TCP 四次挥手


### TCP 与 UDP 的区别
