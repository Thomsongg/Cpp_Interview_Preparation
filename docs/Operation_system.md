# 操作系统

## 进程 & 线程
### 进程和线程的概念
- 进程：系统中正在运行的程序，是**分配资源**的单位。有独立的资源，入内存空间、磁盘空间、I/O设备等
- 线程：**任务调度**的基本单元。各个线程共享父进程的空间和全局变量。而进程有独立的堆栈，存放局部变量，对线程而言不可见。能够**共享地址空间**，高效地共享数据。

同一进程的所有线程共享以下资源：
1. 堆：在进程空间内开辟，可被共享
2. 全局变量
3. 静态变量：类同全局变量，存在于堆中的 .bss 和 .data 段

线程独享的资源：
1. 栈
2. 寄存器
3. 程序计数器

线程运行的本质：函数的执行

### 进程间通信的方式
- 管道 (Pipe / FIFO)
	- 原理：在用户态-内核态分别建立一个管道，实现双工通信。本质是在内核中建立一个缓冲区，一端写数据，一端读数据
    - 缺点：用内核交换数据，传输效率低下，尤其不适合频繁交换数据
    - pipe 用于相关联进程间通信，FIFO 可用于任何进程间

- 消息队列
	- 原理：保存在**内核中的链表**，由一个个独立的数据块组成。消息的发送和接收方事先约定好消息类型。当进程读取消息（数据块）时，从内核中将其删除。
    - 生命周期：内核如果一直不显示，则一直存在。
    - 缺点：
        1. 无法实时通信
        2. 数据块大小限制
        3. 数据需要跨用户-内核拷贝，开销大
        
- 共享内存 (虚拟内存)
	- 原理：每个进程独享一份虚拟内存空间，不同进程的虚拟内存空间映射到对应的物理内存。
    - 优点：不需要跨进程、跨用户-内核间复制，效率高。
- 信号
	- 原理：用来处理异常状态的进程间数据传输。可以在任何时刻给进程发送信号。异步通信。
    - 进程收到信号后的处理方式：
        1. 系统定义的信号函数，执行默认操作
        2. 捕捉信号。由用户决定接下来执行何种操作
        3. 忽略信号。除 SIGKILL SEGSTOP 外，都可以忽略。
    
- unix 域 socket
	- 原理：将应用层数据在进程间拷贝。
    - 不同于 IPC 机制，基于网络协议设计。但面向消息的 UNIX 域 Socket 是可靠的。
    
- 信号量
	- 原理：用于解决多个进程同时操作一个共享内存时的竞争问题。实现共享内存在同一时间只能由一个进程访问。本质上是一个**计数器**。
    - 操作：进程访问时，执行 p 操作，计数减 1；进程访问结束，执行 v 操作，计数加 1
    - 信号量初始值为1. 计数 < 0, 则表示资源被占用，进程阻塞等待；计数 >= 0, 可以正常访问。

#### 信号量 & 互斥量
- 用途不同：互斥量用于线程间互斥，信号量用于进程/线程间**同步**。
- 互斥：阻止同一时间的多次访问。具有唯一性和排他性，但无法限制访问者的访问顺序。
- 同步：在互斥的基础上，实现有序访问。

#### 进程同步
关键：进程间临界区的访问，有效利用临界区资源。

同步的原则：
1. 空闲让进：没有进程访问临界区，则允许一个进程的访问请求。
2. 忙则等待：已经由进程在访问临界区，则要求其他试图访问的进程等待，实现互斥访问。
3. 有限等待：保证等待的时限是有限的，避免死等
4. 让权等待：进程不能进入时，**立即释放处理机**，避免进程忙等

同步的实现机制：
1. 提供临界区代码执行中断的优先级
    - 提升临界区中断优先级，优于其他进程的中断请求，防止其他进程随意进入临界区，修改全局数据库
2. 自旋锁
3. 信号量机制

#### CPU 调度算法 (进程调度算法)
类型：抢占式调度（可打断其他程序）、非抢占式调度（进程完成或阻塞时要让出 CPU 资源）。

调度算法：
1. 先来先服务
2. 最短作业优先
3. 高响应比优先
4. 时间片轮转：每个进程分配特定的时间段（成为时间片），过了时间段就释放进程，分出资源；提前结束或阻塞，就立即切换到其他进程。
5. 最高优先级
6. 多级反馈队列

进程阻塞不消耗 CPU 资源，但消耗系统资源，如内存、磁盘、I/O

### 线程间通信的方式
目的：线程同步

- 锁机制
	- 互斥锁
    - 读写锁：读模式共享，写模式互斥
    - 自旋锁：不阻塞线程，轮询查看能否上锁。零切换开销，但持续消耗 CPU 资源
    
- posix 信号量机制：类似进程间 信号量
- 条件变量
	- 到达特定条件时，唤醒线程
    - 要结合互斥锁使用

### 线程调度
- 协同式调度：
	- 等待线程执行完毕，切换到其他线程
    - 实现简单，没有线程同步问题
    - 线程执行时间不可控
    
- 抢占式调度
	- 系统分配各个线程的时间片
    - 线程切换由系统决定

### 死锁
概念：多个进程对相同资源的竞争，导致互相死等

产生原因：
1. 资源分配不当
2. 进程/线程 运行顺序不合理

死锁的必要条件：
1. 互斥
2. 占有的同时等待：进程的资源获取请求不完全满足，被其他资源额外占用
3. 不可抢占：资源长期占用
4. 循环等待：无序性

如何避免死锁：
1. 解决“占有同时等待”：
    - 提前给所有线程一次性申请好要用的所有资源
    - 进程完成后，释放其使用的资源，再申请新资源，提升利用率
2. 解决“不可抢占”
    - 当进程获取资源的请求无法满足时，释放其自身的资源
3. 解决“循环等待”
    - 所有进程有序申请和分配资源


## 虚拟内存
每个程序独有的地址空间，被分割成若干页。每一页由对应的物理内存映射。

# 数据库
## MySQL 相关
如何存储：将表的定义、数据、索引 分开存储

### MySQL 索引
索引的分类：
1. B+ 树索引
2. 哈希索引
3. 全文索引

#### 为什么使用 B+ 树：
- 主要原因：减少磁盘 I/O 消耗
- B+ 树层数少，查询时对磁盘 I/O 的操作次数较少
- 叶子节点连成链表，适合范围查询

#### 数据库事务
1. 原子性：事务的操作被当作一个完整的逻辑单元，一起操作
2. 一致性：数据更改后，回滚到最初状态
3. 隔离性：允许多个用户对同一个数据并发访问。修改域其他事务独立
4. 持久性：持久保存

#### 锁机制
1. 悲观锁：将数据锁定，屏蔽其他违反当前事务的操作。
    - 产生加锁的开销，且容易死锁
    - 只读型事务，无需加锁。适合频繁写入的事务
2. 乐观锁：
    - 实现方式：版本号机制实现。数据版本机制、时间戳机制
    - 适合对**响应速度**和**并发量**要求高的场景

## Redis
### Redis & MySQL
- MySQL 是持久化数据库、关系型数据库，直接保存在硬盘
- Redis 是非关系型，保存在内存中，适合快速存取数据，适用于实时响应要求高的场景，可作为数据请求量较大的数据的存取，与 MySQL 结合使用


### Redis 的优点
1. 高并发
2. 快速存取

原因：
1. 基于内存，读写速度快，没有磁盘 I/O 操作的开销
2. 单线程，剩余上下文切换线程的时间
3. 使用 I/O 多路复用技术，适合高并发。使用了 Epoll

